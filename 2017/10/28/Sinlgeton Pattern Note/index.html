<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 设计模式读书笔记-单例模式 · Sweeney Di's Blog</title><meta name="description" content="设计模式读书笔记-单例模式 - Sweeney Di"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/December1900/December1900.github.io.git/atom.xml" title="Sweeney Di's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://www.zhihu.com/people/fei-rou-gu-tou" target="_blank" class="nav-list-link">ZHIHU</a></li><li class="nav-list-item"><a href="https://github.com/December1900" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">设计模式读书笔记-单例模式</h1><div class="post-info">Oct 28, 2017</div><div class="post-content"><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>单例模式：确保某一个类只有一个实例，且只能自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。</p>
</blockquote>
<a id="more"></a>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ol>
<li>系统只需要一个实例对象。例如，系统要求提供一个唯一的序列号生成器或者资源管理器，或者需要考虑资源消耗太大只允许创建一个状态（Windows进程管理器无论点击多少次始终只能弹出一个窗口，因为如果多个窗口弹出意味着在某一瞬间系统资源使用情况和进程，服务等信息存在多个状态）。</li>
<li>客户端调用类的单个实例只允许一个公共访问类。</li>
</ol>
<h1 id="单例模式概述"><a href="#单例模式概述" class="headerlink" title="单例模式概述"></a>单例模式概述</h1><p>单例类有很多实现方式，但是基本共同要点在于</p>
<h2 id="构建私有构造函数"><a href="#构建私有构造函数" class="headerlink" title="构建私有构造函数"></a><strong>构建私有构造函数</strong></h2><p>原因在于为了确保单例实例的唯一性，需要禁止类的外部直接用new来创建对象，因此需要将构造函数的可见性改为private<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<h2 id="定义静态Sinleton类型的私有成员变量"><a href="#定义静态Sinleton类型的私有成员变量" class="headerlink" title="定义静态Sinleton类型的私有成员变量"></a><strong>定义静态Sinleton类型的私有成员变量</strong></h2><ul>
<li>类的外部不能使用new来创建对象，但是外部能访问这个唯一实例，同时内部能创建保存这个唯一实例。</li>
<li>为什么成员变量需要定义为静态？因为提供给外部的静态方法不能访问非静态变量。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton single = <span class="keyword">null</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="定义一个公有的静态方法"><a href="#定义一个公有的静态方法" class="headerlink" title="定义一个公有的静态方法"></a><strong>定义一个公有的静态方法</strong></h2><p>提供给外界使用并实例化成员变量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">   <span class="keyword">if</span> (sinlge == <span class="keyword">null</span>)&#123;</div><div class="line">       single = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> tm;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因此最简单经典的单例模式如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton single = <span class="keyword">null</span>;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</div><div class="line">    </div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (single == <span class="keyword">null</span>)&#123;</div><div class="line">      single = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> single;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p> 这是最经典实现方式，结合项目使用情况衍生出更多的实现方式</p>
<ul>
<li>Eager Singleton</li>
<li>Lazy and Thread safe Singleton</li>
<li>Bill Pugh Singleton</li>
<li>Enum Singleton</li>
</ul>
<hr>
<h2 id="饿汉单例"><a href="#饿汉单例" class="headerlink" title="饿汉单例"></a>饿汉单例</h2><p>结构图如下<br><img src="http://oq8w2ddi6.bkt.clouddn.com/blog:dp:eager.png" alt="EagerSingleton"><br>由于在定义静态变量时实例化单例类，因此在类加载的时候就已经创建了单例对象，可确保单例对象的唯一性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EagerSingleton</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EagerSingleton single = <span class="keyword">new</span> EagerSingleton();</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">EagerSinlgeton</span><span class="params">()</span></span>&#123;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EagerSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> single;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="懒汉单例与线程安全"><a href="#懒汉单例与线程安全" class="headerlink" title="懒汉单例与线程安全"></a>懒汉单例与线程安全</h2><p>懒汉单例在第一次调用getInstance()时实例化，在类加载时并不自行实例化，这种技术又称为「<strong>延迟加载（Lazy Load)</strong>」技术，即需要的时候再加载实例。为了避免多个线程同时调用getInstance()方法，可以使用synchronized关键字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton single = <span class="keyword">null</span>;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;</div><div class="line">    </div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (single == <span class="keyword">null</span>)&#123;</div><div class="line">      single = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> single;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样虽然解决了线程安全问题，但是每次调用getInstance()时都需要进行线程锁定判断，在多线程高并发访问环境中，将会导致系统性能大大降低。综合考虑，不用对整个getInstacne()进行锁定，只需锁定<code>single = new Singleton();</code>即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton sinlge = <span class="keyword">null</span>;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">LazySinlgeton</span><span class="params">()</span></span>&#123;</div><div class="line">    </div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">//the fisrt</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstacne</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (single == <span class="keyword">null</span>)&#123;</div><div class="line">      <span class="keyword">synchronized</span>(LazySingleton.class)&#123;</div><div class="line">        single = <span class="keyword">new</span> LazySinleton();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> single;</div><div class="line">  &#125; </div><div class="line">  </div><div class="line">  <span class="comment">//the second</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (single == <span class="keyword">null</span>)&#123;</div><div class="line">      <span class="keyword">synchronized</span>(LazySingleton.class)&#123;</div><div class="line">        <span class="keyword">if</span> (single == <span class="keyword">null</span>)&#123;</div><div class="line">          single = <span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> single;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二种比第一种方法多了一层<code>if (single == null)</code>判断，为什么需要这层判断？不加可不可以?</p>
<p>答案是不行。</p>
<p><strong>如果使用第一种方法来创建单例对象,还是会存在单例对象不唯一。</strong></p>
<p>因为假如A线程和B线程在同一时间调用getInstance()方法，此时均为null值，均能通过<code>single == nulli</code>判断。此时A线程进入synchronized锁定的代码模块执行实例创建，B线程处于排队等待状态，必须等待A线程执行完才能进入synchronized锁定代码模块。但当A线程执行完毕后，B线程并不知道实例已经创建，会再次创建实例导致产生多个实例对象，依然无法保证唯一的单例对象，因此需要再加入一层判断，这种方式称为「<strong>双重检查锁定（Double-Check Locking)</strong> 」</p>
<h2 id="Bill-Pugh-Singleton"><a href="#Bill-Pugh-Singleton" class="headerlink" title="Bill Pugh Singleton"></a>Bill Pugh Singleton</h2><blockquote>
<p>Prior to Java 5, java memory model had a lot of issues and above approaches used to fail in certain scenarios where too many threads try to get the instance of the Singleton class simultaneously. So Bill Pugh came up with a different approach to create the Singleton class using a inner static helper class. The Bill Pugh Singleton implementation goes like this;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BillPughSingleton</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">BillPughSingleton</span><span class="params">()</span></span>&#123;</div><div class="line">    </div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHelper</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BillPughSingleton instacne = <span class="keyword">new</span> BillPughSingleton();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BillPughSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> SingletonHelper.instance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于静态单例对象没有作为BillPushSingleton的成员变量直接实例化，因此类加载时不会实例化Singleton，第一次调用getInstance()时将加载内部类SinlgetonHelper，内部类中的static变量instance会首先被初始化,由JVM来保证其线程安全，确保该成员变量只能初始化一次。</p>
<p>可是为什么这样就是线程安全的呢？很多文章和书籍都没有解释清楚都是一笔带过，JVM保证线程安全。</p>
<p>首先要知道的是<strong>静态变量只会初始化一次当类加载时</strong>。</p>
<p>其次是<strong>Java是多线程编程，初始化类或者接口时需要很精细的同步操作，因为同一时间可能有很多其他的线程尝试去初始化同样的类或接口</strong></p>
<blockquote>
<p>For each class or interface C, there is a unique initialization lock LC. The mapping from C to LC is left to the discretion of the Java Virtual Machine implementation.</p>
</blockquote>
<p>简单来说，当两个线程尝试去初始化<code>instance</code>时，需要LC锁的第一个线程才是实际上去初始化<code>instance</code>的线程，因为它是静态初始化，Java保证它只能被初始化一次。而当其他线程再进入getInstance()时，系统加载执行早已结束，保证了线程安全。</p>
<p>贴上两个摘要更便于理解</p>
<p>Java Concurrency in Practice</p>
<blockquote>
<p>The lazy initialization holder class idiom uses a class whose only purpose is to initialize the Resource. The JVM defers initializing the ResourceHolder class until it is actually used [JLS 12.4.1], and because the Resource is initialized with a static initializer, no additional synchronization is needed. The first call to getresource by any thread causes ResourceHolder to be loaded and initialized, at which time the initialization of the Resource happens through the static initializer.</p>
</blockquote>
<p>Static initialization</p>
<blockquote>
<p>Static initializers are run by the JVM at class initialization time, after class loading but before the class is used by any thread. Because the JVM acquires a lock during initialization [JLS 12.4.2] and this lock is acquired by each thread at least once to ensure that the class has been loaded, memory writes made during static initialization are automatically visible to all threads. Thus statically initialized objects require no explicit synchronization either during construction or when being referenced.</p>
</blockquote>
<h2 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton&#123;</div><div class="line">  INSTANCE;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Sinlgeton</span><span class="params">()</span></span>&#123;</div><div class="line">    </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></div></article></div></main><footer><div class="paginator"><a href="/2017/05/14/Fragment-1/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="https://github.com/December1900/December1900.github.io.git">Sweeney Di</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>